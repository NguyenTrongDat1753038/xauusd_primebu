Để giúp cải thiện hiệu suất trading bot của bạn, tôi sẽ đề xuất một quy trình phân tích và cải tiến theo từng bước. Tuy nhiên, do không trực tiếp thấy được toàn bộ code trong project của bạn, tôi sẽ đưa ra các hướng tiếp cận chung và những điểm cần kiểm tra:

### 1. Phân tích hệ thống hiện tại
Trước khi cải tiến, cần hiểu rõ:
- Các indicators đang sử dụng trong `strategies.py`
- Logic vào lệnh trong `combined_strategy.py`
- Các điều kiện lọc tín hiệu (filter)
- Quản lý rủi ro hiện tại

### 2. Cải tiến đề xuất

#### a) Đa dạng hóa strategies (strategies.py)
```python
# Thêm các indicators phổ biến khác
def add_adx(self, period=14):
    self.data['adx'] = ta.ADX(self.data.high, self.data.low, self.data.close, period)

def add_atr(self, period=14):
    self.data['atr'] = ta.ATR(self.data.high, self.data.low, self.data.close, period)

def add_volume_indicators(self):
    self.data['obv'] = ta.OBV(self.data.close, self.data.volume)
    # Thêm các indicators về volume khác
```

#### b) Kết hợp nhiều khung thời gian (combined_strategy.py)
```python
def check_multiple_timeframes(self):
    # Lấy dữ liệu từ khung thời gian cao hơn (ví dụ: H4 nếu đang trade H1)
    higher_tf_data = get_higher_timeframe_data()
    
    # Chỉ trade theo xu hướng khung lớn
    if higher_tf_data['trend'] == 'up':
        return 'long'
    elif higher_tf_data['trend'] == 'down':
        return 'short'
    return None
```

#### c) Tối ưu điều kiện vào lệnh
```python
def generate_signal(self):
    # Thêm nhiều lớp xác nhận
    conditions = [
        self.macd_crossover(),
        self.rsi_confirmation(),
        self.price_above_ema(),
        self.volume_confirmation(),
        not self.is_overbought() if going_long else not self.is_oversold()
    ]
    
    # Yêu cầu ít nhất 3/5 điều kiện được thỏa mãn
    if sum(conditions) >= 3:
        return 'long' if conditions[0] else 'short'
    return None
```

#### d) Dynamic Position Sizing (quản lý vốn thông minh)
```python
def calculate_position_size(self, atr_value, account_balance=10000, risk_percent=1):
    risk_amount = account_balance * risk_percent / 100
    position_size = risk_amount / (atr_value * 1.5)  # Sử dụng ATR để tính biến động
    
    return round(position_size, 2)
```

#### e) Thêm bộ lọc tin tức/thời gian
```python
def is_safe_to_trade(self):
    # Tránh các sự kiện quan trọng
    if economic_calendar.is_high_impact_event():
        return False
        
    # Tránh giờ thanh khoản thấp (tùy market)
    if not (9 <= datetime.now().hour <= 16):
        return False
        
    return True
```

### 3. Kiểm tra và tối ưu backtesting

Thêm logging chi tiết:
```python
class BacktestLogger:
    def log_trade(self, trade):
        details = {
            'entry_time': trade.entry_time,
            'exit_time': trade.exit_time,
            'duration': trade.duration,
            'entry_price': trade.entry_price,
            'exit_price': trade.exit_price,
            'profit': trade.profit_pct,
            'indicators_at_entry': {
                'rsi': current_rsi,
                'macd': current_macd,
                # ... thêm các indicators khác
            },
            'win_reason': trade.win_reason if trade.profit > 0 else None,
            'loss_reason': trade.loss_reason if trade.profit <= 0 else None
        }
        save_to_database(details)
```

### 4. Triển khai Machine Learning (nếu có thể)

```python
from sklearn.ensemble import RandomForestClassifier

class MLSignalGenerator:
    def __init__(self):
        self.model = RandomForestClassifier(n_estimators=100)
        
    def train_model(self, historical_data):
        X = historical_data[['rsi', 'macd', 'volume', ...]] 
        y = historical_data['outcome']  # 1 cho win, 0 cho loss
        
        self.model.fit(X_train, y_train)
        
    def predict_signal(self, current_features):
        proba = self.model.predict_proba([current_features])
        
        # Chỉ giao dịch khi xác suất > threshold nhất định
        if proba[0][1] > 0.65:  
            return True
        return False
```

### Triển khai từng bước:

1. **Phân tích backtest hiện tại**: Xem các lệnh lose nhiều nhất có điểm chung gì?
2. **Thêm indicators mới**: Như ADX cho xu hướng mạnh/yếu...
3. **Tối ưu parameters**: Dùng grid search hoặc optimization để tìm tham số tốt nhất 
4. **Thêm bộ lọc**: Giảm số lượng giao dịch nhưng tăng chất lượng 
5. **Triển khai quản lý vốn adaptive**

Bạn có thể chia sẻ cụ thể hơn về logic vào lệnh hiện tại và các indicators đang sử dụng để tôi có thể đề xuất chi tiết hơn không? Đặc biệt là phần `combined_strategy.py` - cách bạn kết hợp các tín hiệu như thế nào?